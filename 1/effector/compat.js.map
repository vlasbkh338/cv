{"version":3,"file":"compat.js","sources":["effector/createNode.ts","effector/naming.ts","effector/collection.ts","effector/createUnit.ts","effector/combine.ts","effector/defer.ts","effector/createEffect.ts","effector/sample.ts","effector/fork.ts","effector/kernel.ts","effector/observable.ts","effector/validate.ts","effector/throw.ts","effector/is.ts","effector/id.ts","effector/bind.ts","effector/step.ts","effector/stateRef.ts","effector/caller.ts","effector/getter.ts","effector/own.ts","effector/config.ts","effector/clearNode.ts","effector/subscription.ts","effector/region.ts","effector/forward.ts","effector/watch.ts","effector/createDomain.ts","effector/attach.ts","effector/createApi.ts","effector/fromObservable.ts","effector/guard.ts","effector/merge.ts","effector/restore.ts","effector/split.ts"],"sourcesContent":["import {Graph, Graphite, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {nextNodeID} from './id'\n\nconst arrifyNodes = (list: Graphite | Graphite[] = []): Graph[] => {\n  const result = []\n  if (Array.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      if (Array.isArray(list[i])) result.push(...(list[i] as any))\n      else result.push(list[i])\n    }\n  } else {\n    result.push(list)\n  }\n  return result.map(getGraph)\n}\nexport const addToReg = (\n  {hasRef, type, data}: any,\n  reg: Record<string, StateRef>,\n) => {\n  let store\n  if (hasRef) {\n    store = data.store\n    reg[store.id] = store\n  }\n  if (type === 'mov' && data.to === 'store') {\n    store = data.target\n    reg[store.id] = store\n  }\n}\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: Graphite | Graphite[]\n  source?: Graphite | Graphite[]\n  parent?: Graphite | Graphite[]\n  to?: Graphite | Graphite[]\n  target?: Graphite | Graphite[]\n  child?: Graphite | Graphite[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: Graphite | Graphite[]\n    owners?: Graphite | Graphite[]\n  }\n} = {}): Graph {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  const reg: {[id: string]: StateRef} = {}\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n    addToReg(item, reg)\n  }\n  const result: Graph = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || 'crosslink',\n      links,\n      owners,\n    },\n    reg,\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  return result\n}\n","import {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\n\nexport const joinName = (unit: any, tag: string) => '' + unit.shortName + tag\n\nexport const mapName = (unit: any, name?: string) =>\n  name == null ? joinName(unit, ' → *') : name\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  //@ts-ignore\n  for (const key in objOrArr) {\n    //@ts-ignore\n    const unit = objOrArr[key]\n    if (unit != null) {\n      name += comma\n      //@ts-ignore\n      name += is.unit(unit) ? unit.compositeName.fullName : unit.toString()\n    }\n    i += 1\n    /* inlined max object names constant */\n    if (i === 25) break\n    comma = ', '\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, getParent(store))\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  const currentComposite = store.compositeName\n  currentComposite.path = compositeName.path\n  currentComposite.shortName = compositeName.shortName\n  currentComposite.fullName = compositeName.fullName\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  let composite\n  const shortName = name\n  if (!parent) {\n    if (name.length === 0) {\n      path = []\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    composite = parent.compositeName\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      if (composite.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + composite.fullName + '/' + name\n      }\n    }\n  }\n  return {shortName, fullName, path}\n}\n","export const forIn = (obj: any, cb: (value: any, key: string) => void) => {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = (list: any[], item: any) => list.includes(item)\n\nexport const removeItem = (list: any[], item: any) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","import {observableSymbol} from './observable'\n\nimport {is, isObject, isFunction, assertObject} from './is'\nimport {Store, Event} from './unit.h'\n\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {bind} from './bind'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, currentPage, forkPage, setCurrentPage} from './kernel'\n\nimport {Subscriber, Config} from './index.h'\nimport {createName, mapName, joinName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {addToRegion, readTemplate} from './region'\nimport {\n  getSubscribers,\n  getConfig,\n  getNestedConfig,\n  getStoreState,\n  getGraph,\n  getParent,\n} from './getter'\nimport {includes} from './collection'\nimport {throwError} from './throw'\n\nconst normalizeConfig = (part: any, config: any) => {\n  if (isObject(part)) {\n    normalizeConfig(getConfig(part), config)\n    if (part.name != null) {\n      if (isObject(part.name)) normalizeConfig(part.name, config)\n      else if (isFunction(part.name)) config.handler = part.name\n      else config.name = part.name\n    }\n    if (part.loc) config.loc = part.loc\n    if (part.sid || part.sid === null) config.sid = part.sid\n    if (part.handler) config.handler = part.handler\n    if (getParent(part)) config.parent = getParent(part)\n    if ('strict' in part) config.strict = part.strict\n    if (part.named) config.named = part.named\n    normalizeConfig(getNestedConfig(part), config)\n  }\n  return config\n}\n\nexport const applyParentHook = (\n  source: any,\n  target: any,\n  hookType: 'event' | 'effect' = 'event',\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nlet isStrict: boolean\nexport const initUnit = (\n  kind: any,\n  unit: any,\n  rawConfigA: any,\n  rawConfigB?: any,\n) => {\n  const config = normalizeConfig(\n    {\n      name: rawConfigB,\n      config: rawConfigA,\n    },\n    {},\n  )\n  const id = nextUnitID()\n  const {parent = null, sid = null, strict = true, named = null} = config\n  const name = named ? named : config.name || (kind === 'domain' ? '' : id)\n  const compositeName = createName(name, parent)\n  unit.kind = kind\n  unit.id = id\n  unit.sid = sid\n  unit.shortName = name\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => fn(unit)\n  unit.getType = () => compositeName.fullName\n  if (kind !== 'domain') {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => {\n              if (observer.next) {\n                observer.next(upd)\n              }\n            },\n      )\n    }\n    unit[observableSymbol] = () => unit\n  }\n  isStrict = strict\n  return {unit: kind, name, sid, named}\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst createComputation = (from: any, to: any, op: any, fn: Function) =>\n  createLinkNode(from, to, {\n    scope: {fn},\n    node: [step.compute({fn: callStack})],\n    meta: {op},\n  })\n\nconst createEventFiltration = (event: any, op: string, fn: any, node: any) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent(joinName(event, ' →? *'), config)\n  createLinkNode(event, mapped, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n  return mapped\n}\n\nfunction callCreate(unit: any, template: any, payload: any, args: any[]): any {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) => {\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }\n  event.graphite = createNode({\n    meta: initUnit('event', event, maybeConfig, nameOrConfig),\n  })\n  //eslint-disable-next-line no-unused-vars\n  event.create = (payload: any, _: any) => {\n    const target = forkPage ? forkPage.find(event) : event\n    launch(target, payload)\n    return payload\n  }\n  event.watch = bind(watchUnit, event)\n  event.map = (fn: any) => {\n    let config\n    let name\n    if (isObject(fn)) {\n      config = fn\n      name = fn.name\n      fn = fn.fn\n    }\n    const mapped = createEvent(mapName(event, name), config)\n    createComputation(event, mapped, 'map', fn)\n    return mapped\n  }\n  event.filter = (fn: any) =>\n    createEventFiltration(event, 'filter', fn.fn ? fn : fn.fn, [\n      step.filter({fn: callStack}),\n    ])\n  event.filterMap = (fn: any) =>\n    createEventFiltration(event, 'filterMap', fn, [\n      step.compute({fn: callStack}),\n      step.check.defined(),\n    ])\n  event.prepend = (fn: any) => {\n    const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n      parent: getParent(event),\n    })\n    const template = readTemplate()\n    if (template) {\n      getGraph(contramapped).seq.push(template.upward)\n    }\n    createComputation(contramapped, event, 'prepend', fn)\n    applyParentHook(event, contramapped)\n    return contramapped\n  }\n  const template = readTemplate()\n  if (template) {\n    getGraph(event).meta.nativeTemplate = template\n  }\n  return addToRegion(event)\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const oldState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  const template = readTemplate()\n  plainState.after = [{type: 'copy', to: oldState}]\n  if (template) {\n    template.plain.push(plainState, oldState)\n  }\n  const plainStateId = plainState.id\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage && forkPage.reg[plainStateId]) {\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState(state: any) {\n      let target\n      if (forkPage) {\n        target = forkPage.nodeMap[getGraph(store).id]\n      }\n      if (!target) target = store\n      launch({\n        target,\n        params: state,\n        defer: true,\n      })\n    },\n    reset(...units: any[]) {\n      for (const unit of units) store.on(unit, () => store.defaultState)\n      return store\n    },\n    on(events: any, fn: Function) {\n      if (Array.isArray(events)) {\n        for (const event of events) {\n          onEvent(event, fn)\n        }\n      } else {\n        onEvent(events, fn)\n      }\n      return store\n    },\n    off(unit: any) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: any, firstState?: any) {\n      let config\n      let name\n      if (isObject(fn)) {\n        config = fn\n        name = fn.name\n        firstState = fn.firstState\n        fn = fn.fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (storeState !== undefined) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: mapName(store, name),\n        config,\n        strict: false,\n      })\n      const linkNode = updateStore(store, innerStore, 'map', false, fn)\n\n      getStoreState(innerStore).before = [\n        {\n          type: 'map',\n          fn,\n          from: plainState,\n        },\n      ]\n      if (template) {\n        if (!includes(template.plain, plainState)) {\n          if (!includes(linkNode.seq, template.loader)) {\n            linkNode.seq.unshift(template.loader)\n          }\n        }\n      }\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        const template = readTemplate()\n        if (template) {\n          template.watch.push({\n            of: plainState,\n            fn: eventOrFn,\n          })\n        } else {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      if (!isFunction(fn)) throwError('second argument should be a function')\n      return eventOrFn.watch((payload: any) => fn(store.getState(), payload))\n    },\n  }\n  function onEvent(event: any, fn: Function) {\n    store.off(event)\n    getSubscribers(store).set(\n      event,\n      createSubscription(updateStore(event, store, 'on', true, fn)),\n    )\n  }\n  store.graphite = createNode({\n    scope: {state: plainState},\n    node: [\n      step.check.defined(),\n      step.update({\n        store: plainState,\n      }),\n      step.check.changed({\n        store: oldState,\n      }),\n      step.update({\n        store: oldState,\n      }),\n    ],\n    child: updates,\n    meta: initUnit('store', store, props),\n  })\n  if (isStrict && defaultState === undefined)\n    throwError(\"current state can't be undefined, use null instead\")\n  if (template) {\n    getGraph(store).meta.nativeTemplate = template\n  }\n  own(store, [updates])\n  return addToRegion(store)\n}\n\nconst updateStore = (\n  from: any,\n  store: Store<any>,\n  op: string,\n  stateFirst: boolean,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const node = [\n    step.mov({store: storeRef, to: 'a'}),\n    step.compute({\n      fn: stateFirst ? callARegStack : callStackAReg,\n    }),\n    step.check.defined(),\n    step.check.changed({store: storeRef}),\n    step.update({store: storeRef}),\n  ]\n  const template = readTemplate()\n  if (template) {\n    node.unshift(template.loader)\n    node.push(template.upward)\n    if (is.store(from)) {\n      const ref = getStoreState(from)\n      if (!includes(template.plain, ref)) {\n        //if (!includes(node, template.loader)) {\n        //  node.unshift(template.loader)\n        //}\n        if (!includes(template.closure, ref)) {\n          template.closure.push(ref)\n        }\n        if (!storeRef.before) storeRef.before = []\n        storeRef.before.push({\n          type: 'closure',\n          of: ref,\n        })\n      }\n    } else {\n      //if (!includes(node, template.loader)) {\n      //  node.unshift(template.loader)\n      //}\n    }\n  }\n  return createLinkNode(from, store, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n}\n","import {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef} from './stateRef'\nimport {step} from './typedef'\nimport {onConfigNesting} from './config'\nimport {getStoreState} from './getter'\nimport {is, isFunction, isObject} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {throwError} from './throw'\nimport {readTemplate} from './region'\nimport {forIn, includes} from './collection'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  onConfigNesting(args[0], (injectedData, userConfig) => {\n    config = injectedData\n    args = userConfig\n  })\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  if (!isObject(structStoreShape)) throwError('shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst spreadArgs = (fn: Function) => (list: any[]) => fn(...list)\n\nconst storeCombination = (\n  isArray: boolean,\n  obj: any,\n  config?: string,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray\n    ? (list: any) => list.slice()\n    : (obj: any) => Object.assign({}, obj)\n  const defaultState: any = isArray ? [] : {}\n  const template = readTemplate()\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  if (template) {\n    template.plain.push(rawShape, isFresh)\n  }\n  const store = createStore(stateNew, {\n    name: config ? config : unitObjectName(obj),\n  })\n  const node = [\n    step.check.defined(),\n    step.mov({\n      store: rawShape,\n      to: 'a',\n    }),\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {key}, {a}) => upd !== a[key],\n    }),\n    step.mov({\n      store: isFresh,\n      to: 'b',\n    }),\n    step.compute({\n      fn(upd, {clone, key}, reg) {\n        if (reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n      },\n    }),\n    step.mov({\n      from: 'a',\n      target: rawShape,\n    }),\n    step.mov({\n      from: 'value',\n      store: false,\n      target: isFresh,\n    }),\n    step.barrier({priority: 'barrier'}),\n    step.mov({\n      from: 'value',\n      store: true,\n      target: isFresh,\n    }),\n    step.mov({store: rawShape}),\n    fn && step.compute({fn}),\n    step.check.changed({\n      store: getStoreState(store),\n    }),\n  ]\n  const before: any[] = (rawShape.before = [])\n  forIn(obj, (child, key) => {\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, {\n      scope: {key, clone},\n      node,\n      meta: {op: 'combine'},\n    })\n    const childRef = getStoreState(child)\n    before.push({\n      type: 'field',\n      field: key,\n      from: childRef,\n    })\n    if (template) {\n      if (!includes(template.plain, childRef)) {\n        linkNode.seq.unshift(template.loader)\n      }\n    }\n  })\n\n  store.defaultShape = obj\n  rawShape.after = [\n    fn\n      ? {\n          type: 'map',\n          to: getStoreState(store),\n          fn,\n        }\n      : {\n          type: 'copy',\n          to: getStoreState(store),\n        },\n  ]\n  if (!template) {\n    store.defaultState = fn\n      ? (getStoreState(store).current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n","export function createDefer(): {\n  rs: (value: any) => any\n  rj: (value: any) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value: any) => any\n    rj: (value: any) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import {step} from './typedef'\nimport {getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {throwError} from './throw'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig: any,\n) {\n  const instance: any = createEvent(nameOrConfig, maybeConfig)\n  let handler =\n    instance.defaultConfig.handler ||\n    (() => throwError(`no handler used in ${instance.getType()}`))\n\n  getGraph(instance).meta.onCopy = ['runner']\n  getGraph(instance).meta.unit = instance.kind = 'effect'\n  instance.use = (fn: Function) => {\n    if (!isFunction(fn)) throwError('.use argument should be a function')\n    handler = fn\n    return instance\n  }\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}: any) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}: any) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: any) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: any) => error,\n  }))\n\n  const effectRunner = createNode({\n    scope: {\n      getHandler: instance.use.getCurrent = () => handler,\n      finally: anyway,\n    },\n    node: [\n      step.run({\n        fn({params, req}, {finally: anyway, getHandler}, {page, forkPage}) {\n          const onResolve = onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            page,\n            forkPage,\n          })\n          const onReject = onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            page,\n            forkPage,\n          })\n          let result\n          try {\n            result = getHandler()(params)\n          } catch (err) {\n            return void onReject(err)\n          }\n          if (isObject(result) && isFunction(result.then)) {\n            result.then(onResolve, onReject)\n          } else {\n            onResolve(result)\n          }\n        },\n      }),\n    ],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally'],\n    },\n  })\n  getGraph(instance).scope.runner = effectRunner\n  getGraph(instance).seq.push(\n    step.compute({\n      fn(params, scope, stack) {\n        // empty stack means that this node was launched directly\n        if (!getParent(stack)) return params\n        return {\n          params,\n          req: {\n            rs(data: any) {},\n            rj(data: any) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn(upd, {runner}, {forkPage}) {\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          forkPage,\n        })\n        return upd.params\n      },\n    }),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      const savedFork = forkPage\n      req.req.finally(() => {\n        setForkPage(savedFork)\n      })\n      launch(forkPage.find(instance), payload)\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n\n  const pending = (instance.pending = inFlight.map({\n    //@ts-ignore\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [\n    anyway,\n    done,\n    fail,\n    doneData,\n    failData,\n    pending,\n    inFlight,\n    effectRunner,\n  ])\n  return instance\n}\n\nexport const onSettled = ({\n  params,\n  req,\n  ok,\n  anyway,\n  page,\n  forkPage,\n}: {\n  params: any\n  req: {\n    rs(_: any): any\n    rj(_: any): any\n  }\n  ok: boolean\n  anyway: any\n  page: any\n  forkPage: any\n}) => (data: any) =>\n  launch({\n    target: [anyway, sidechain],\n    params: [\n      ok\n        ? {\n            status: 'done',\n            params,\n            result: data,\n          }\n        : {\n            status: 'fail',\n            params,\n            error: data,\n          },\n      {\n        fn: ok ? req.rs : req.rj,\n        value: data,\n      },\n    ],\n    defer: true,\n    page,\n    forkPage,\n  })\n\nconst sidechain = createNode({\n  node: [\n    step.run({\n      fn({fn, value}) {\n        fn(value)\n      },\n    }),\n  ],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import {combine} from './combine'\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {addToRegion, readTemplate} from './region'\nimport {throwError} from './throw'\nimport {includes} from './collection'\n\nexport function sample(...args: any): any {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let greedy\n  //config case\n  if (clock === undefined && 'source' in source) {\n    if ('clock' in source && source.clock == null)\n      throwError('config.clock should be defined')\n    clock = source.clock\n    fn = source.fn\n    greedy = source.greedy\n    //optional target & name accepted only from config\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  if (!is.unit(source)) {\n    source = combine(source)\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  name = metadata || name || source.shortName\n  const template = readTemplate()\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid})\n    } else {\n      target = createEvent(name)\n      if (template) {\n        getGraph(target).seq.push(template.loader)\n      }\n    }\n  }\n  const targetTemplate =\n    isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    const sourceRef = getStoreState(source)\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {fn, targetTemplate},\n        node: [\n          template && template.loader,\n          //@ts-ignore\n          !greedy && step.barrier({priority: 'sampler'}),\n          step.mov({\n            store: sourceRef,\n            to: fn ? 'a' : 'stack',\n          }),\n          fn && step.compute({fn: callARegStack}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: 'sample', sample: 'store'},\n      }),\n    ])\n    if (template) {\n      if (\n        !includes(template.plain, sourceRef) &&\n        !includes(template.closure, sourceRef)\n      ) {\n        template.closure.push(sourceRef)\n      }\n    }\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceState = createStateRef()\n    const clockState = createStateRef()\n    if (template) {\n      template.plain.push(hasSource, sourceState, clockState)\n    }\n    addToRegion(\n      createNode({\n        parent: source,\n        node: [\n          step.update({store: sourceState}),\n          step.mov({\n            from: 'value',\n            store: true,\n            target: hasSource,\n          }),\n        ],\n        family: {\n          owners: [source, target, clock],\n          links: target,\n        },\n        meta: {op: 'sample', sample: 'source'},\n      }),\n    )\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {\n          fn,\n          targetTemplate,\n        },\n        node: [\n          template && template.loader,\n          step.update({store: clockState}),\n          step.mov({store: hasSource}),\n          step.filter({fn: hasSource => hasSource}),\n          //@ts-ignore\n          !greedy && step.barrier({priority: 'sampler'}),\n          step.mov({store: sourceState}),\n          step.mov({\n            store: clockState,\n            to: 'a',\n          }),\n          fn && step.compute({fn: callStackAReg}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: 'sample', sample: 'clock'},\n      }),\n    ])\n  }\n  return target\n}\n","import {getGraph} from './getter'\nimport {bind} from './bind'\nimport {createDefer} from './defer'\nimport {watchUnit} from './watch'\nimport {is, isObject} from './is'\nimport {throwError} from './throw'\nimport {launch, forkPage, setForkPage} from './kernel'\nimport {createNode} from './createNode'\nimport {step} from './typedef'\nimport {Domain, Store} from './unit.h'\nimport {Graph, StateRef} from './index.h'\nimport {removeItem, forEach, includes} from './collection'\n\n/**\nhydrate state on client\n\nconst root = createDomain()\nhydrate(root, {\n  values: window.__initialState__\n})\n\n*/\nexport function hydrate(domain: Domain, {values}: {values: any}) {\n  if (!is.domain(domain)) {\n    throwError('first argument of hydrate should be domain')\n  }\n  if (!isObject(values)) {\n    throwError('values property should be an object')\n  }\n\n  const {storeWatches, storeWatchesRefs} = fillValues({\n    flatGraphUnits: flatGraph(domain),\n    values: normalizeValues(values),\n    collectWatches: true,\n  })\n\n  launch({\n    target: storeWatches,\n    params: storeWatchesRefs.map(({current}) => current),\n  })\n}\n\nfunction fillValues({\n  flatGraphUnits,\n  values,\n  collectWatches,\n}: {\n  flatGraphUnits: Graph[]\n  values: Record<string, any>\n  collectWatches: boolean\n}) {\n  const storeWatches = []\n  const storeWatchesRefs = []\n  const refsMap = {} as Record<string, StateRef>\n  const predefinedRefs = new Set()\n  const valuesSidList = Object.getOwnPropertyNames(values)\n  for (const node of flatGraphUnits) {\n    const {reg} = node\n    const {op, unit, sid} = node.meta\n    if (unit === 'store') {\n      if (sid && includes(valuesSidList, sid)) {\n        const {state} = node.scope\n        state.current = values[sid]\n        predefinedRefs.add(state)\n      }\n    }\n    if (collectWatches && op === 'watch') {\n      const owner = node.family.owners[0]\n      if (owner.meta.unit === 'store') {\n        storeWatches.push(node)\n        storeWatchesRefs.push(owner.scope.state)\n      }\n    }\n    for (const id in reg) {\n      refsMap[id] = reg[id]\n    }\n  }\n  const refGraph = createRefGraph(refsMap)\n  const result = toposort(refGraph)\n  forEach(result, id => {\n    execRef(refsMap[id])\n  })\n\n  return {\n    storeWatches,\n    storeWatchesRefs,\n  }\n  function execRef(ref: StateRef) {\n    let isFresh = false\n    if (ref.before && !predefinedRefs.has(ref)) {\n      for (const cmd of ref.before) {\n        switch (cmd.type) {\n          case 'map': {\n            const from = cmd.from\n            ref.current = cmd.fn(from.current)\n            break\n          }\n          case 'field': {\n            const from = cmd.from\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            ref.current[cmd.field] = from.current\n            break\n          }\n          case 'closure':\n            break\n        }\n      }\n    }\n    if (!ref.after) return\n    const value = ref.current\n    for (const cmd of ref.after) {\n      const to = cmd.to\n      // if (predefinedRefs.has(to)) continue\n      switch (cmd.type) {\n        case 'copy':\n          to.current = value\n          break\n        case 'map':\n          to.current = cmd.fn(value)\n          break\n      }\n    }\n  }\n}\n\nfunction createRefGraph(refsMap: Record<string, StateRef>) {\n  const items = Object.values(refsMap)\n  const refGraph = {} as Record<string, string[]>\n  for (const {id} of items) {\n    refGraph[id] = []\n  }\n  //prettier-ignore\n  for (const {id, before, after} of items) {\n    before && forEach(before, cmd => {\n      refGraph[cmd.from.id].push(id)\n    })\n    after && forEach(after, cmd => {\n      refGraph[id].push(cmd.to.id)\n    })\n  }\n  return refGraph\n}\n\n/**\nserialize state on server\n*/\nexport function serialize(\n  {clones, getState, cloneOf}: any,\n  {\n    ignore = [],\n    onlyChanges,\n  }: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  const result = {} as Record<string, any>\n  if (onlyChanges) {\n    ignore = [...ignore]\n    for (const store of cloneOf.history.stores) {\n      if (getState(store) === store.defaultState) {\n        ignore.push(store)\n      }\n    }\n  }\n  for (const {meta, scope, reg} of clones) {\n    if (meta.unit !== 'store') continue\n    const {sid} = meta\n    if (!sid) continue\n    result[sid] = reg[scope.state.id].current\n  }\n  for (const {sid} of ignore) {\n    if (sid) delete result[sid]\n  }\n  return result\n}\n\n/** bind event to scope */\nexport function scopeBind(unit: any) {\n  if (!forkPage) {\n    throwError('scopeBind cannot be called outside of forked .watch')\n  }\n  const result = forkPage.find(unit)\n  const savedStack = forkPage\n  return (payload: any) => {\n    launch({\n      target: result,\n      params: payload,\n      forkPage: savedStack,\n    })\n  }\n}\n\nfunction normalizeValues(values: Map<Store<any>, any> | Record<string, any>) {\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    for (const [key, value] of values) {\n      result[key.sid!] = value\n    }\n    return result\n  }\n  return values\n}\nexport function fork(\n  domain: Domain,\n  {values, handlers}: {values?: any; handlers?: any} = {},\n) {\n  if (!is.domain(domain)) throwError('first argument of fork should be domain')\n  const needToFill = !!values\n  values = normalizeValues(values || {})\n  const forked = cloneGraph(domain)\n  if (needToFill) {\n    fillValues()\n  }\n  if (handlers) {\n    handlers = normalizeValues(handlers)\n    const handlerKeys = Object.keys(handlers)\n    for (const {scope, meta} of forked.clones) {\n      if (meta.sid && includes(handlerKeys, meta.sid)) {\n        scope.runner.scope.getHandler = () => handlers[meta.sid]\n      }\n    }\n  }\n  return forked\n\n  function fillValues() {\n    const sourceList = flatGraph(domain)\n    const sourceRefsMap = {} as Record<string, StateRef>\n    const refsMap = {} as Record<string, StateRef>\n    const predefinedRefs = new Set()\n    const templateOwnedRefs = new Set<string>()\n    const valuesSidList = Object.getOwnPropertyNames(values)\n    for (const {reg, meta} of sourceList) {\n      const {nativeTemplate} = meta\n      for (const id in reg) {\n        sourceRefsMap[id] = reg[id]\n        if (nativeTemplate) {\n          templateOwnedRefs.add(id)\n        }\n      }\n    }\n    for (const node of forked.clones) {\n      const {reg} = node\n      const {unit, sid} = node.meta\n      if (unit === 'store') {\n        if (sid && includes(valuesSidList, sid)) {\n          const {state} = node.scope\n          reg[state.id].current = values[sid]\n          predefinedRefs.add(state)\n        }\n      }\n      for (const id in reg) {\n        refsMap[id] = reg[id]\n      }\n    }\n    const refGraph = createRefGraph(sourceRefsMap)\n    const result = toposort(refGraph, templateOwnedRefs)\n    forEach(result, id => {\n      execRef(refsMap[id], sourceRefsMap[id])\n    })\n\n    function execRef(ref: StateRef, sourceRef?: StateRef) {\n      let isFresh = false\n      if (sourceRef && sourceRef.before && !predefinedRefs.has(ref)) {\n        for (const cmd of sourceRef.before) {\n          switch (cmd.type) {\n            case 'map': {\n              const from = refsMap[cmd.from.id]\n              ref.current = cmd.fn(from.current)\n              break\n            }\n            case 'field': {\n              const from = refsMap[cmd.from.id]\n              if (!isFresh) {\n                isFresh = true\n                if (Array.isArray(ref.current)) {\n                  ref.current = [...ref.current]\n                } else {\n                  ref.current = {...ref.current}\n                }\n              }\n              ref.current[cmd.field] = from.current\n              break\n            }\n            case 'closure':\n              break\n          }\n        }\n      }\n      if (!sourceRef || !sourceRef.after) return\n      const value = ref.current\n      for (const cmd of sourceRef.after) {\n        const to = refsMap[cmd.to.id]\n        // if (predefinedRefs.has(to)) continue\n        switch (cmd.type) {\n          case 'copy':\n            to.current = value\n            break\n          case 'map':\n            to.current = cmd.fn(value)\n            break\n        }\n      }\n    }\n  }\n}\nfunction toposort(rawGraph: Record<string, string[]>, ignore?: Set<string>) {\n  const graph = {} as Record<string, string[]>\n  for (const id in rawGraph) {\n    graph[id] = [...new Set(rawGraph[id])]\n  }\n  const result = [] as string[]\n  const visited = {} as Record<string, boolean>\n  const temp = {} as Record<string, boolean>\n  for (const node in graph) {\n    if (!visited[node] && !temp[node]) {\n      topologicalSortHelper(node)\n    }\n  }\n  result.reverse()\n  if (ignore && ignore.size > 0) {\n    const processed = [] as string[]\n    const ignored = [...ignore]\n    let item: string | void\n    while ((item = ignored.shift())) {\n      processed.push(item)\n      forEach(graph[item], child => {\n        if (includes(processed, child) || includes(ignored, child)) return\n        ignored.push(child)\n      })\n    }\n    forEach(processed, item => {\n      removeItem(result, item)\n    })\n  }\n  return result\n  function topologicalSortHelper(node: string) {\n    temp[node] = true\n    const neighbors = graph[node]\n    for (let i = 0; i < neighbors.length; i++) {\n      const n = neighbors[i]\n      if (temp[n]) {\n        continue\n        // throw Error('found cycle in DAG')\n      }\n      if (!visited[n]) {\n        topologicalSortHelper(n)\n      }\n    }\n    temp[node] = false\n    visited[node] = true\n    result.push(node)\n  }\n}\nexport function allSettled(\n  start: any,\n  {scope, params: ctx}: {scope: any; params?: any},\n) {\n  if (!is.unit(start))\n    return Promise.reject(Error('first argument should be unit'))\n  const defer = createDefer()\n  //@ts-ignore\n  defer.parentFork = forkPage\n  const {forkInFlightCounter} = scope.graphite.scope\n  forkInFlightCounter.scope.defers.push(defer)\n  const contextStart = scope.find(start)\n\n  const launchUnits = [contextStart]\n  const launchParams = []\n  if (is.effect(start)) {\n    launchParams.push({\n      params: ctx,\n      req: {\n        rs(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'done', value}\n        },\n        rj(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'fail', value}\n        },\n      },\n    })\n  } else {\n    launchParams.push(ctx)\n  }\n  launchUnits.push(forkInFlightCounter)\n  launchParams.push(null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    forkPage: scope,\n  })\n  return defer.req\n}\nfunction flatGraph(unit: any) {\n  const list = [] as Graph[]\n  ;(function traverse(node) {\n    if (includes(list, node)) return\n    list.push(node)\n    forEachRelatedNode(node, traverse)\n  })(getGraph(unit))\n  return list\n}\n/**\neverything we need to clone graph section\nreachable from given unit\n*/\nfunction cloneGraph(unit: any) {\n  const list = flatGraph(unit)\n  const refs = new Map()\n  const scope = {\n    defers: [],\n    inFlight: 0,\n    fxID: 0,\n  }\n  const forkPageSetter = step.compute({\n    fn(data, _, stack) {\n      setForkPage(stack.forkPage)\n      return data\n    },\n  })\n  const forkInFlightCounter = createNode({\n    scope,\n    node: [\n      step.compute({\n        fn(_, scope, stack) {\n          if (!stack.parent) {\n            scope.fxID += 1\n            return\n          }\n          if (stack.parent.node.meta.named === 'finally') {\n            scope.inFlight -= 1\n          } else {\n            scope.inFlight += 1\n            scope.fxID += 1\n          }\n        },\n      }),\n      step.barrier({priority: 'sampler'}),\n      step.run({\n        fn(_, scope) {\n          const {inFlight, defers, fxID} = scope\n          if (inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), (defer: any) => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n      }),\n    ],\n    meta: {unit: 'forkInFlightCounter'},\n  })\n  const nodeMap = {} as Record<string, Graph>\n  const clones = list.map(node => {\n    const {seq, next, meta, scope, family} = node\n    const result = createNode({\n      node: seq.map(step => ({\n        id: step.id,\n        type: step.type,\n        data: Object.assign({}, step.data),\n        hasRef: step.hasRef,\n      })) as any,\n      child: [...next],\n      meta: Object.assign({forkOf: node}, meta),\n      scope: Object.assign({}, scope),\n    })\n    result.family = {\n      type: family.type,\n      links: [...family.links],\n      owners: [...family.owners],\n    }\n    nodeMap[node.id] = result\n    return result\n  })\n  const page = {} as Record<string, StateRef>\n  forEach(clones, node => {\n    const {\n      reg,\n      scope,\n      meta: {onCopy, op, unit},\n    } = node\n    for (const id in reg) {\n      const ref = reg[id]\n      let newRef = refs.get(ref)\n      if (!newRef) {\n        newRef = {\n          id: ref.id,\n          current: ref.current, //ref.id in values ? values[ref.id] : ref.current,\n        }\n        refs.set(ref, newRef)\n      }\n      page[id] = reg[id] = newRef\n    }\n    if (onCopy) {\n      for (let j = 0; j < onCopy.length; j++) {\n        scope[onCopy[j]] = findClone(scope[onCopy[j]])\n      }\n    }\n    forEachRelatedNode(node, (node, i, siblings) => {\n      siblings[i] = findClone(node)\n    })\n    const itemTag = op || unit\n    switch (itemTag) {\n      case 'store':\n        node.meta.wrapped = wrapStore(node)\n        break\n      case 'event':\n        node.seq.unshift(forkPageSetter)\n        break\n      case 'effect':\n        node.next.push(forkInFlightCounter)\n        node.seq.unshift(forkPageSetter)\n        break\n      case 'fx': {\n        scope.finally.next.push(forkInFlightCounter)\n        node.seq.unshift(forkPageSetter)\n        break\n      }\n      case 'watch':\n        node.seq.unshift(forkPageSetter)\n        break\n    }\n  })\n\n  return {\n    cloneOf: unit,\n    nodeMap,\n    clones,\n    find: findClone,\n    reg: page,\n    getState: (store: any) => findClone(store).meta.wrapped.getState(),\n    graphite: createNode({\n      family: {\n        type: 'domain',\n        links: [forkInFlightCounter, ...clones],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n  }\n  function findClone(unit: any) {\n    unit = getGraph(unit)\n    const index = list.indexOf(unit)\n    if (index === -1) throwError('unit not found in forked scope')\n    return clones[index]\n  }\n}\n\nfunction wrapStore(node: Graph) {\n  return {\n    kind: 'store',\n    getState: () => node.reg[node.scope.state.id].current,\n    updates: {\n      watch: bind(watchUnit, node),\n    },\n    graphite: node,\n    family: node.family,\n  }\n}\nfunction forEachRelatedNode(\n  {next, family, meta}: Graph,\n  cb: (node: Graph, index: number, siblings: Graph[]) => void,\n) {\n  if (meta.unit === 'fork' || meta.unit === 'forkInFlightCounter') return\n  forEach(next, cb)\n  forEach(family.owners, cb)\n  forEach(family.links, cb)\n}\n","import {Graphite, Graph} from './index.h'\nimport {readRef} from './stateRef'\nimport {getGraph, getValue} from './getter'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Graph\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\ntype Stack = {\n  value: any\n  a: any\n  b: any\n  parent: Stack | null\n  node: Graph\n  page: {[id: string]: any} | null\n  forkPage?: any\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  const isSameType = a.v.type === b.v.type\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (isSameType && a.v.id > b.v.id) ||\n    /** if first node is \"sampler\" and second node is \"barrier\" */\n    (!isSameType && a.v.type === 'sampler')\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 5) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  queue.push({first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 5; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * second bucket is for \"barrier\" PriorityType (used in combine)\n       * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 2 || i === 3) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: {[id: string]: any} | null,\n  node: Graph,\n  parent: Stack | null,\n  value: any,\n  forkPage: any | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      forkPage,\n    },\n    type,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id = 0) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    //@ts-ignore\n    l: 0,\n    //@ts-ignore\n    r: 0,\n  }\n  /**\n   * second bucket is for \"barrier\" PriorityType (used in combine)\n   * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 2 || priority === 3) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'barrier':\n      return 2\n    case 'sampler':\n      return 3\n    case 'effect':\n      return 4\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set()\n\nlet alreadyStarted = false\nexport let currentPage: any = null\nexport let forkPage: any\nexport const setForkPage = (newForkPage: any) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: any) => {\n  currentPage = newPage\n}\n\n/** main execution method */\nconst exec = () => {\n  const lastStartedState = {alreadyStarted, currentPage, forkPage}\n  alreadyStarted = true\n  let stop\n  let skip\n  let graph\n  let value\n  let page\n  let reg\n  mem: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    graph = stack.node\n    currentPage = page = stack.page\n    forkPage = stack.forkPage\n    reg = (page ? page : graph).reg\n    const local: Local = {\n      fail: false,\n      scope: graph.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < graph.seq.length && !stop; stepn++) {\n      const step = graph.seq[stepn]\n      const data = step.data\n      switch (step.type) {\n        case 'barrier': {\n          let id = data.barrierID\n          if (page) {\n            id = `${page.fullID}_${id}`\n          }\n          const priority = data.priority\n          if (stepn !== idx || type !== priority) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, id)\n            }\n            continue mem\n          }\n          barriers.delete(id)\n          break\n        }\n        case 'mov': {\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case 'stack': value = getValue(stack); break\n            case 'a': value = stack.a; break\n            case 'b': value = stack.b; break\n            case 'value': value = data.store; break\n            case 'store':\n              if (!reg[data.store.id]) {\n                // if (!page.parent) {\n                stack.page = page = null\n                reg = graph.reg\n                // }\n              }\n              value = readRef(reg[data.store.id])\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case 'stack': stack.value = value; break\n            case 'a': stack.a = value; break\n            case 'b': stack.b = value; break\n            case 'store':\n              reg[data.target.id].current = value\n              break\n          }\n          break\n        }\n        case 'check':\n          switch (data.type) {\n            case 'defined':\n              skip = getValue(stack) === undefined\n              break\n            case 'changed':\n              skip = getValue(stack) === readRef(reg[data.store.id])\n              break\n          }\n          break\n        case 'filter':\n          /**\n           * handled edge case: if step.fn will throw,\n           * tryRun will return null\n           * thereby forcing that branch to stop\n           */\n          skip = !tryRun(local, data, stack)\n          break\n        case 'run':\n          /** exec 'compute' step when stepn === idx */\n          if (stepn !== idx || type !== 'effect') {\n            pushHeap(stepn, stack, 'effect')\n            continue mem\n          }\n        case 'compute':\n          stack.value = tryRun(local, data, stack)\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      for (let stepn = 0; stepn < graph.next.length; stepn++) {\n        pushFirstHeapItem(\n          'child',\n          page,\n          graph.next[stepn],\n          stack,\n          getValue(stack),\n          stack.forkPage,\n        )\n      }\n    }\n  }\n  alreadyStarted = lastStartedState.alreadyStarted\n  currentPage = lastStartedState.currentPage\n  forkPage = lastStartedState.forkPage\n}\nexport const launch = (unit: any, payload?: any, upsert?: boolean) => {\n  let page = currentPage\n  let stack = null\n  let forkedPage = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    page = 'page' in unit ? unit.page : page\n    if (unit.stack) stack = unit.stack\n    forkedPage = unit.forkPage || forkedPage\n    unit = unit.target\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        page,\n        getGraph(unit[i]),\n        stack,\n        payload[i],\n        forkedPage,\n      )\n    }\n  } else {\n    pushFirstHeapItem('pure', page, getGraph(unit), stack, payload, forkedPage)\n  }\n  if (upsert && alreadyStarted) return\n  exec()\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, {fn}: any, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","export const observableSymbol: any =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import {kind} from './index.h'\n\nimport {isObject, isFunction} from './is'\n\nexport const unit = (obj: any) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: any) => unit(obj) && obj.kind === type\n\nexport const store = is('store')\nexport const event = is('event')\nexport const effect = is('effect')\nexport const domain = is('domain')\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect first argument be an object') // or function\n}\n","const idCount = () => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","export const bind = (fn: Function, target: any) => fn.bind(null, target)\nexport const bind2 = (fn: Function, target: any, arg: any) =>\n  fn.bind(null, target, arg)\n","import {StateRef, Run, Filter, Compute, Barrier, Check, Mov} from './index.h'\nimport {nextStepID} from './id'\nimport {bind2} from './bind'\n\nconst cmd = (type: any, hasRef: boolean, data: any): any => ({\n  id: nextStepID(),\n  type,\n  data,\n  hasRef,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier: (data: {priority?: 'barrier' | 'sampler'}) => Barrier = ({\n  priority = 'barrier',\n}) =>\n  cmd('barrier', false, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: (data: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b'\n  store?: any\n  target?: any\n}) => Mov = ({\n  from = 'store',\n  store,\n  target,\n  to = target ? 'store' : 'stack',\n}) => cmd('mov', from === 'store', {from, store, to, target})\nexport const check: {\n  defined(): Check\n  changed(config: {store: StateRef}): Check\n} = {\n  defined: () => cmd('check', false, {type: 'defined'}),\n  changed: ({store}) => cmd('check', true, {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Compute = bind2(cmd, 'compute', false)\nexport const filter: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Filter = bind2(cmd, 'filter', false)\nexport const run: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Run = bind2(cmd, 'run', false)\nexport const update: (data: {store: StateRef}) => Mov = ({store}) =>\n  mov({from: 'stack', target: store})\n","import {StateRef} from './index.h'\nimport {nextStepID} from './id'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n","export const callStackAReg = (stack: any, {fn}: any, {a}: any) => fn(stack, a)\nexport const callARegStack = (stack: any, {fn}: any, {a}: any) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: any, _: any) => fn(stack)\n","import {Graph} from './index.h'\n\nexport const getGraph = (graph: any): Graph => graph.graphite || graph\nexport const getOwners = (node: Graph) => node.family.owners\nexport const getLinks = (node: Graph) => node.family.links\nexport const getStoreState = (store: any) => store.stateRef\nexport const getConfig = (opts: any) => opts.config\nexport const getNestedConfig = (opts: any) => opts.ɔ\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: any) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\n","import {Graphite} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\n\nexport const own = (ownerUnit: Graphite, links: Graphite[]) => {\n  const owner = getGraph(ownerUnit)\n  for (let i = 0; i < links.length; i++) {\n    const link = getGraph(links[i])\n    if (owner.family.type !== 'domain') link.family.type = 'crosslink'\n    getOwners(link).push(owner)\n    getLinks(owner).push(link)\n  }\n}\n","import {getConfig, getNestedConfig} from './getter'\nimport {assertObject} from './is'\n\nexport const onConfigNesting = (\n  rawConfig: any,\n  fn: (babelData: any, userConfig: any) => void,\n) => {\n  assertObject(rawConfig)\n  if (getNestedConfig(rawConfig)) {\n    fn(getConfig(rawConfig), getNestedConfig(rawConfig))\n  }\n}\n\nexport const processArgsToConfig = (args: any[]): [any[], any | void] => {\n  let metadata\n  onConfigNesting(args[0], (injected, config) => {\n    metadata = injected\n    args = config\n  })\n  return [args, metadata]\n}\n","import {Graph, Graphite} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\n\nconst removeFromNode = (currentNode: Graph, targetNode: Graph) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Graph,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-ignore\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !targetNode.meta.sample) ||\n      currentNode.family.type === 'crosslink'\n    ) {\n      clearNodeNormalized(currentNode, deep, isDomainUnit)\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === 'crosslink') {\n      clearNodeNormalized(currentNode, deep, isDomainUnit)\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: Graphite,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-ignore\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    //@ts-ignore\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import {Subscription, Graphite} from './index.h'\nimport {bind2} from './bind'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: Graphite): Subscription => {\n  const result = bind2(clearNode, node, undefined)\n  result.unsubscribe = result\n  return result\n}\n","import {getValue, getGraph, getParent} from './getter'\nimport {own} from './own'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: any\n}\n\nexport const addToRegion = (unit: any) => {\n  if (regionStack) own(getValue(regionStack), [unit])\n  return unit\n}\n\nlet regionStack: RegionStack | null = null\n\nexport const readTemplate = () => regionStack && regionStack.template\n\nexport function withRegion(unit: any, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template:\n      getGraph(unit).meta.template || (regionStack && regionStack.template),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n","import {onConfigNesting} from './config'\nimport {createNode} from './createNode'\nimport {Subscription, Graphite, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {throwError} from './throw'\nimport {addToRegion} from './region'\n\nexport const createLinkNode = (\n  parent: Graphite,\n  child: Graphite,\n  {\n    node,\n    scope,\n    meta,\n  }: {\n    node?: Array<Cmd | false | void | null>\n    scope?: {[name: string]: any}\n    meta?: {[name: string]: any}\n  },\n) =>\n  addToRegion(\n    createNode({\n      node,\n      parent,\n      child,\n      scope,\n      meta,\n      family: {\n        owners: [parent, child],\n        links: child,\n      },\n    }),\n  )\nexport const forward = (opts: {\n  from: Graphite | Graphite[]\n  to: Graphite | Graphite[]\n  meta?: Record<string, any>\n}): Subscription => {\n  let config\n  onConfigNesting(opts, (injectedData, userConfig) => {\n    config = injectedData\n    opts = userConfig\n  })\n  const {from, to, meta = {op: 'forward'}} = opts\n  if (!from || !to) throwError('from and to fields should be defined')\n  if (config) meta.config = config\n  return createSubscription(\n    addToRegion(\n      createNode({\n        parent: from,\n        child: to,\n        meta,\n        family: {},\n      }),\n    ),\n  )\n}\n","import {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, Unit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {addToRegion} from './region'\nimport {throwError} from './throw'\nimport {isFunction} from './is'\nimport {forkPage} from './kernel'\nimport {getGraph} from './getter'\n\nexport const watchUnit = (\n  unit: Unit,\n  handler: (payload: any) => any,\n): Subscription => {\n  if (!isFunction(handler)) throwError('.watch argument should be a function')\n  if (forkPage) {\n    const forkedNode = forkPage.nodeMap[getGraph(unit).id]\n    if (forkedNode) unit = forkedNode\n  }\n  return createSubscription(\n    addToRegion(\n      createNode({\n        scope: {fn: handler},\n        node: [step.run({fn: callStack})],\n        parent: unit,\n        meta: {op: 'watch'},\n        family: {\n          owners: unit,\n        },\n      }),\n    ),\n  )\n}\n","import {Store, Event, Effect, Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {Config} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {forward} from './forward'\nimport {addToRegion} from './region'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\n\nconst createHook = (trigger: Event<any>, acc: Set<any>, node: any) => {\n  trigger.watch(data => {\n    own(node, [data])\n    acc.add(data)\n    if (!data.ownerSet) data.ownerSet = acc\n    if (!getParent(data)) data.parent = node\n  })\n  own(node, [trigger])\n  return (hook: (data: any) => any) => {\n    acc.forEach(hook)\n    return trigger.watch(hook)\n  }\n}\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const domains: Set<Domain> = new Set()\n  const stores: Set<Store<any>> = new Set()\n  const effects: Set<Effect<any, any, any>> = new Set()\n  const events: Set<Event<any>> = new Set()\n\n  const node = createNode({\n    family: {type: 'domain'},\n  })\n\n  const result: any = {\n    history: {\n      domains,\n      stores,\n      effects,\n      events,\n    },\n    graphite: node,\n  }\n\n  node.meta = initUnit('domain', result, maybeConfig, nameOrConfig)\n  const [event, effect, store, domain] = [\n    'onEvent',\n    'onEffect',\n    'onStore',\n    'onDomain',\n  ].map(createNamedEvent)\n\n  result.hooks = {\n    event,\n    effect,\n    store,\n    domain,\n  }\n  result.onCreateEvent = createHook(event, events, result)\n  result.onCreateEffect = createHook(effect, effects, result)\n  result.onCreateStore = createHook(store, stores, result)\n  result.onCreateDomain = createHook(domain, domains, result)\n\n  result.createEvent = result.event = (nameOrConfig: any, config?: Config) =>\n    event(\n      createEvent(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createEffect = result.effect = (nameOrConfig: any, config?: Config) =>\n    effect(\n      createEffect(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createDomain = result.domain = (nameOrConfig: any, config?: Config) =>\n    createDomain({\n      name: nameOrConfig,\n      parent: result,\n      config,\n    })\n  result.createStore = result.store = (state: any, config?: Config) =>\n    store(\n      createStore(state, {\n        parent: result,\n        config,\n      }),\n    )\n  addToRegion(result)\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from, key) => {\n      forward({from, to: parent.hooks[key]})\n    })\n    parent.hooks.domain(result)\n  }\n  return result\n}\n","import {combine} from './combine'\nimport {createEffect, onSettled} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {step} from './typedef'\nimport {launch} from './kernel'\nimport {addToReg} from './createNode'\nimport {throwError} from './throw'\n\nexport function attach(config: any) {\n  let injected\n  onConfigNesting(config, (injectedData, userConfig) => {\n    injected = injectedData\n    config = userConfig\n  })\n  let {source, effect, mapParams} = config\n  if (!source && !mapParams)\n    throwError('either `mapParams` or `source` should be defined')\n  if (!mapParams) mapParams = (_: any, source: any) => source\n  const attached = createEffect(config, injected)\n  const {runner} = getGraph(attached).scope\n\n  let runnerSteps\n  const runnerFn = (\n    {params, req}: any,\n    {finally: anyway, effect}: any,\n    {a: states, page, forkPage}: any,\n  ) => {\n    const rj = onSettled({\n      params,\n      req,\n      ok: false,\n      anyway,\n      page,\n      forkPage,\n    })\n    let computedParams\n    try {\n      computedParams = mapParams(params, states)\n    } catch (err) {\n      return rj(err)\n    }\n    launch({\n      target: effect,\n      params: {\n        params: computedParams,\n        req: {\n          rs: onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            page,\n            forkPage,\n          }),\n          rj,\n        },\n      },\n      page,\n      defer: true,\n    })\n  }\n  if (source) {\n    let state\n    if (is.store(source)) state = source\n    else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    const readStateRef = step.mov({\n      from: 'store',\n      store: getStoreState(state),\n      to: 'a',\n    })\n    runnerSteps = [\n      /* let another side-effects run first */\n      step.run({fn: _ => _}),\n      /* read state. assumed it already stable here because of previous step */\n      readStateRef,\n      /* no need for step.run because of first step */\n      step.compute({fn: runnerFn}),\n    ]\n    addToReg(readStateRef, runner.reg)\n  } else {\n    runnerSteps = [step.run({fn: runnerFn})]\n  }\n  runner.scope.effect = effect\n  runner.meta.onCopy.push('effect')\n  runner.seq.splice(0, 1, ...runnerSteps)\n  applyParentHook(effect, attached, 'effect')\n  return attached\n}\n","import {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import {observableSymbol} from './observable'\nimport {Event} from './unit.h'\nimport {clearNode} from './clearNode'\nimport {createEvent} from './createUnit'\nimport {bind2} from './bind'\nimport {assertObject} from './is'\nimport {throwError} from './throw'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  if (!observableItem.subscribe)\n    throwError('expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = bind2(clearNode, event, undefined)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import {processArgsToConfig} from './config'\nimport {createLinkNode} from './forward'\nimport {sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {addToRegion} from './region'\nimport {throwError} from './throw'\n\nexport function guard(...args: any[]) {\n  const meta: Record<string, any> = {op: 'guard'}\n  let rawName = 'guard'\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (metadata) {\n    meta.config = metadata\n    if (metadata.name) rawName = metadata.name\n  }\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  const {filter, greedy, name = rawName} = config\n  const target = config.target || createEvent(name, meta.config)\n  if (!is.unit(source)) source = combine(source)\n\n  if (is.unit(filter)) {\n    sample({\n      source: filter,\n      clock: source,\n      target: addToRegion(\n        createNode({\n          node: [\n            step.filter({\n              fn: ({guard}) => guard,\n            }),\n            step.compute({\n              fn: ({data}) => data,\n            }),\n          ],\n          child: target,\n          meta,\n          family: {\n            owners: [source, filter, target],\n            links: target,\n          },\n        }),\n      ),\n      fn: (guard: any, data: any) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    if (!isFunction(filter)) throwError('`filter` should be function or unit')\n    createLinkNode(source, target, {\n      scope: {fn: filter},\n      node: [step.filter({fn: callStack})],\n      meta,\n    })\n  }\n  return target\n}\n","import {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {forward} from './forward'\nimport {unitObjectName} from './naming'\n\nexport function merge<T>(\n  events: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n): Event<T> {\n  const result = createEvent(unitObjectName(events, 'merge'))\n  forward({\n    from: events,\n    to: result,\n    meta: {op: 'merge'},\n  })\n  return result\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.unit(obj)) {\n    const domain = getParent(obj)\n    let result\n    if (is.event(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj, (_, v) => v)\n    }\n    if (is.effect(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj.done, (_: any, {result}: any) => result)\n    }\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(obj, (value, key) => {\n    result[key] = is.store(value) ? value : createStore(value, {name: key})\n  })\n  return result\n}\n","import {Event} from './unit.h'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {forward} from './forward'\nimport {processArgsToConfig} from './config'\n\nexport function split(...args: any[]): any {\n  let cases: any\n  let [[unit, match], metadata] = processArgsToConfig(args)\n  const knownCases = !match\n  if (knownCases) {\n    cases = unit.cases\n    match = unit.match\n    unit = unit.source\n  }\n  const result = {} as Record<string, Event<any>>\n  let current: Event<any> = is.store(unit) ? unit.updates : unit\n  forIn(match, (fn, key) => {\n    //@ts-ignore\n    result[key] = current.filter({fn, config: metadata})\n    //@ts-ignore\n    current = current.filter({\n      fn: data => !fn(data),\n      config: metadata,\n    })\n  })\n  result.__ = current\n  if (knownCases) {\n    forIn(result, (event, key) => {\n      if (cases[key]) {\n        forward({\n          from: event,\n          to: cases[key],\n        })\n      }\n    })\n  } else return result\n}\n"],"names":["createNode","node","parent","child","to","target","scope","meta","family","familyRaw","type","sources","arrifyNodes","from","source","links","owners","seq","reg","i","length","item","push","addToReg","result","id","nextNodeID","next","getOwners","getLinks","unitObjectName","objOrArr","method","name","comma","key","unit","is","compositeName","fullName","toString","createName","path","composite","shortName","concat","forEach","list","fn","callCreate","template","payload","args","oldPage","currentPage","page","getParent","setCurrentPage","create","createEvent","nameOrConfig","maybeConfig","event","graphite","initUnit","forkPage","find","launch","watch","bind","watchUnit","map","config","isObject","mapped","mapName","createComputation","filter","createEventFiltration","step","callStack","filterMap","defined","prepend","contramapped","readTemplate","getGraph","upward","applyParentHook","nativeTemplate","addToRegion","createStore","defaultState","props","onEvent","store","off","getSubscribers","set","createSubscription","updateStore","plainState","createStateRef","oldState","updates","createNamedEvent","after","plain","plainStateId","subscribers","Map","stateRef","getState","reachedPage","targetRef","readRef","setState","state","nodeMap","params","defer","reset","units","on","events","Array","isArray","currentSubscription","get","delete","firstState","lastResult","storeState","undefined","innerStore","strict","linkNode","getStoreState","before","includes","loader","unshift","eventOrFn","subscription","of","isFunction","throwError","changed","isStrict","own","combine","handler","stores","onConfigNesting","injectedData","userConfig","structStoreShape","shapeReady","rawHandler","slice","obj","spreadArgs","storeCombination","createDefer","req","Promise","rs","rj","catch","createEffect","instance","defaultConfig","getType","onCopy","kind","use","anyway","finally","done","named","status","fail","error","doneData","failData","effectRunner","getHandler","getCurrent","onResolve","onSettled","ok","onReject","err","then","op","fx","runner","stack","upd","savedFork","setForkPage","inFlight","x","pending","amount","sample","sid","greedy","processArgsToConfig","clock","metadata","isUpward","initialState","targetTemplate","sourceRef","createLinkNode","priority","callARegStack","closure","hasSource","sourceState","clockState","callStackAReg","createRefGraph","refsMap","items","Object","values","refGraph","cmd","normalizeValues","toposort","rawGraph","ignore","topologicalSortHelper","temp","neighbors","graph","n","visited","Set","reverse","size","processed","ignored","shift","removeItem","flatGraph","traverse","forEachRelatedNode","cb","observableSymbol","Symbol","observable","effect","domain","message","Error","value","assertObject","idCount","nextUnitID","nextStepID","bind2","arg","hasRef","data","nextBarrierID","barrier","barrierID","mov","check","compute","run","update","current","a","getConfig","opts","getNestedConfig","ɔ","getValue","ownerUnit","owner","link","heap","merge","b","ret","isSameType","v","r","l","queue","ix","first","last","deleteMin","pushFirstHeapItem","pushHeap","idx","getPriority","bucket","t","barriers","alreadyStarted","newForkPage","newPage","upsert","forkedPage","stop","skip","lastStartedState","mem","local","stepn","fullID","has","add","tryRun","exec","console","joinName","tag","rawConfig","injected","forIn","pos","indexOf","splice","removeFromNode","currentNode","targetNode","clearMap","clear","clearNode","deep","isDomainUnit","ownerSet","history","effects","domains","clearNodeNormalized","pop","unsubscribe","regionStack","forward","forkedNode","hookType","hooks","rawConfigA","rawConfigB","normalizeConfig","part","loc","thru","subscribe","observer","stateFirst","storeRef","ref","clone","assign","stateNew","rawShape","isFresh","childRef","field","defaultShape","sidechain","createHook","trigger","acc","hook","start","ctx","reject","parentFork","forkInFlightCounter","defers","launchUnits","launchParams","mapParams","_","runnerSteps","attached","runnerFn","computedParams","states","readStateRef","setters","createDomain","onCreateEvent","onCreateEffect","onCreateStore","onCreateDomain","handlers","needToFill","forked","findClone","index","clones","refs","forkPageSetter","fxID","resolve","forkOf","newRef","j","siblings","wrapped","wrapStore","cloneOf","cloneGraph","sourceList","sourceRefsMap","predefinedRefs","templateOwnedRefs","valuesSidList","getOwnPropertyNames","execRef","fillValues","handlerKeys","keys","observableItem","disposer","complete","rawName","guard","flatGraphUnits","collectWatches","storeWatches","storeWatchesRefs","savedStack","onlyChanges","currentComposite","cases","match","knownCases","__"],"mappings":"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"}